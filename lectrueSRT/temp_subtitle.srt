So we've now gotten through all the lectures on machine code

我们已经完成了机器级代码的所有课程

And we're starting to talk about...

接下来......

Okay now that you know this stuff what can you do with it

我们已经知道了机器级代码，以及我们能用它来做什么

And this lecture is along the lines of that

这节课是基于机器级代码的课程

This is sort of what you are now empowered to do now that you can look at an understand machine code

现在你可以看懂机器级代码

This material is a little this actually there's a whole chapter of the book chapter five on performance optimization

这节课实际上覆盖了课本的第五章 优化程序性能

And we're only going to do one lecture on it

但我们只上一节课

And we don't have any labs

并且，也没有课后实验（现在已经有第五章的lab了）

Unfortunately that really get you to push your limits on this which is too bad

这种课程安排确实有点可惜

Because it's a very interesting topic

因为这是一个非常有趣的话题

One I think you'd find yourself well equipped for

一个我认为你应该掌握的知识点

There are typically a few small exam problems that are sort of based on some of the material here

这一章，考试中只会出一些小的题目

You'll find in old exams

可以参考以前考试的题目

But really the idea is how can I make programs run fast

这一章的主题是，如果让程序运行更快

Given that I sort of know what algorithm I'm using

这里，运行的更快指的是算法已经确定了

And I've perhaps gotten a program that runs

并且程序可以正确运行

How can I make it run faster

如何让它运行得更快

And one of the the themes of it is

这是我们这一章的主题

You can sort of do this in layers

你可以在不同的层面上做这件事情

You can sort of first of do the stuff to avoid a sort of things that make programs run slow across a wide variety of machines

比如，你可以先去掉程序中不必要的工作，这个优化不依赖与目标机器

Just make your...

这会让你的程序运行更快...

And I would describe it as making your code more compiler friendly, we'll talk about what that means

后面我会讲什么是编译器友好代码

And you have to have some understanding and appreciation for what compilers are good at

要编写出编译器友好的代码，你必须明白什么代码编译器能够优化

And what they're not good at to be able to do that

什么代码编译器无法优化

And I describe these is the kind of things that you should just be in the habit of

并且你应该养成习惯

When you write programs writing this code that I'll describe is compiler friendly

编写代码的时候，编写的代码都是编译器友好的代码

And then the next level is okay given that I've sort of taken away the things that really shouldn't have been there in the first place

我们已经去掉了程序中不必要的代码，下一步是

Now how can I make my programs run faster

我们如何让程序运行得更快

In particular,how can I adapt it to the capabilities of the types of machines that this program is going to run on

特别是，我们如何针对特定的机器对程序进行优化

And that can again go from ones that will generally make programs run fast across a wide variety of machines to ones that

也就是从对大多数机器的优化，转移到了对

Become very specific

特定机器的优化

Very specific is a risky thing because even in the world of  say x86 machines

针对特定机器优化是一个冒险的事情，因为例如 x86 的机器

There's quite a variety of them that are available at any given point in time

在每个时间点，它们都有各种不同的型号

And they evolve over time as well

并且不同的型号也随着时间的推移而发展

So you can make a program run really fast on one particular model of one x86 processor

因此，可能在一个 x86 处理器的特定型号上运行速度较快

But it might not that...

但在另一台 x86 机器上运行速度可能较慢......

If you're trying too hard you'll find your effort is sort of wasted when you move it to another

当你把优化的程序移到另一个机器时，你会发现你的努力有点浪费

On the other hand these general ideas I'm going to describe actually work across quite a range of machines

另一方面，我将要描述的这些一般性想法实际上适用于各种各样的机器

So and I'll talk about that more as we go along

随着我们的进展，我会更多地谈论这个问题

So it used to be in the bad old days that

以前

If you wanted a program to run fast you had to write an assembly code

如果你希望程序快速运行，则你必须编写汇编代码

And that's just plain not true anymore and if anyone tells you it's true

而这显然不再是真的，如果有人告诉你这是真的

It's because they're full of it, it's just not true

这是因为他们对这个不了解，事实并非如此

Unless except for the exceptional case where you're running on a very small resource constrained machine

除非程序运行在资源非常小的机器上

Such as a very small underpowered embedded system

比如程序运行在一个非常小的计算力不足的嵌入式系统上

So let's just assume that we're going to use a compiler

我们使用的编译器为 gcc

And we'll assume for this course we're going to use gcc because it's generally available

我们这个课程使用 gcc 作为编译器，是因为 gcc 的获取比较方面

It's not actually the best compiler out there intel makes a compiler that costs money to license and stuff

它实际上并不是最好的编译器，但英特尔制造的编译器需要花钱才能使用

But it really can do some amazing things and other compilers exist

虽然有其他编译器，但事实上 gcc 可以做到较好的优化

But GCC is sort of a a good enough compiler for most people

对于大多数人来说，gcc 是一个足够好的编译器

But there's some features of some things that sort of puzzle compilers that they don't really understand

但是有些东西和特性编译器是不能真正理解的

Compilers don't really understand for example that the numbers you're using

例如，编译器并不真正理解你正在使用的数字

When you say it's an int might actually range over a much smaller set of values

当你定义一个 int，但实际上它的取值范围是比 int 范围小很多的子集

And they have a very hard time understanding memory referencing patterns and the effect of procedure calls

编译器也很难理解内存引用模式和过程调用的影响

And so in general what happens with the compiler is it

一般来说，编译器

Has a whole sort of cookbook of optimization strategies

有一整套优化策略

And some recipes for how to try out different strategies and apply them

以及如何使用这些优化方案的方法

But in general if it ever feels like this code is something that

但总的来说，如果编译器如果对代码

It doesn't feel confident about being able to make certain transformations

能够进行某些优化不够确定

That it just won't,it will keep things sort of a more direct implementation of exactly what you described

编译器不会优化，会采取直接的实现方法

We'll show examples of that as we go along

讲的过程中，我会展示这方面的例子

So the thing about it optimizing compilers it always has a fallback position which is to not optimize

编译器的优化方案中总有一个备选方案，即不优化

And sometimes that will get in trouble if you want your program to run faster

如果你希望程序运行得更快，你有可能遇到麻烦

And the compiler just in its own conservative white decides not to do that optimization

因为编译器选择了不对代码进行优化

And one of the tricks that you'll find is pretty useful

这时你可以使用一个非常有用的技巧

Now that you can read assembly code is you run the compiler

因为你可以阅读汇编代码，所以你可以编译程序

You see what optimizations it does

看看编译器做了哪些优化

And if it doesn't make something that you expect it to be able to do you go back and figure it out

如果编译器没有做到你想要的优化，你就回去看代码，找到原因

So it's very common by the way to rewrite your program in the same language

因此，用同一种语言重写程序

And sort of tune it in and up to make it run faster to make it more compiler friendly

并对其进行调整以使其运行得更快，更加编译器友好

That's there's nothing wrong with that

这是一种常用的优化程序的方法

As long as you don't then just totally obliterate the program and make it totally illegible

只要你不把这个程序改的完全无法阅读

So let's just describe some sort of general optimizations

所以我们只讲一些通用的优化方式

And you've actually seen versions of this,in some of the assembly code we've already looked at

这里的汇编代码的一些版本我们前面已经看过了

Oh and I'll use mostly sort of examples from multi-dimensional arrays

我们使用的大多数例子是多维数组

Because those are actually fairly easy optimization type of tasks

因为多维数组是相当容易优化的任务

But these applied to other types of program as well

但这些优化方法也适用于其他的程序

So you saw before when we described how to do array indexing in multi-dimensional arrays

我们已经学习过了，怎么对一个多维数组中的元素进行索引

That the old style of code was if you had a a variable sized array

C 原来的代码风格是，如果你有一个二维数组

It was up to you the programmer to write the formula of how you convert row i column j into a position in a one-dimensional array

程序员可以将第 i 行第 j 列转换为一维数组中的位置

So remember it's just the number of columns times the row number plus the column numbers standard one

这个转化的公式是，每一行的列数乘以 i 加上列号 j

So that would give this would be pretty typical code

所以这是非常常用的代码

Then it would give you a notation like this

所以会抽象出这样一个函数

If you wanted to set one row in array 'a' to the values in a one dimensional row of 'b'

将二维数组 a 中的一行设置为一维数组 b 的值

This is a code you'd write

这是你要编写的函数

And the main observation is within this loop

我们主要观察这个循环体

The only variable that's changing is j

唯一变化的变量是 j

And so from the array perspective your this computation n*i··

所以从数组的角度来看，n*i 这个计算...

If it gets repeated over and over again within this loop

如果它在这个循环中反复执行

Then you're just wasting,it's a wasted effort

仅仅只是一种浪费

So you can do what's called code motion

所以你可以一种叫做代码移动的优化方式

Which is to precompute the value of n*i outside of the loop

在循环外预先计算 n*i 的值

And then use it over and over again inside and compilers will generally do this

然后在内部一遍又一遍地使用它，编译器通常会这样做

When they can detect for example that it's a array access code and it has this technique

当编译器可以检测到它是一个数组访问代码，并且编译器有这种技术时

It will generally do optimizations like this if you set say an optimization level of 1 or higher to GCC

如果你将 gcc 的优化级别设置为 1 或更高，它通常会进行这样的优化

And we can see this in fact this is this code that I ran it through GCC using optimization 1

我们实际上可以查看使用 gcc，优化级别为 1 编译后的汇编代码

And you see as this read instruction shows it boosted this multiplication outside of the loop

并且你看到在访问数组元素之前，即循环体之外增加了这个乘法操作

And it's a little as if you actually this code does even more

实际上这个代码还做了另外的优化

It turns the code into something that looks more like a pointer code

它将代码转换为指针风格的代码

Accessing array 'a' and stepping through that element by element of the array

使用指针来访问数组 a，然后每次循环，指针的值加 1

Another one and we've seen this already that when

另外，我们可以看到

GCC turns a multiplication or a division by shifting and adding an operations like that

gcc 通过移位和加法运算来实现

Multiplication or division by constants

一个操作数为常数乘法和除法

We've seen examples of that and a similar one would happen if

我们已经看到过这样的例子，类似的

If we took that program I showed before and applied it to every row

在之前的程序中，这个方法会应用于每一次对数组的访问

So we want to set for array 'a' we wanted to set every one of its rows to the value of the one dimensional array 'b'

现在，我们要将二维数组 a 的每一行设置为一维数组 b 的值

Then again if we took that code we boosted the n*i in there

然后，如果我们可是使用左边的代码，我们预先计算了 n*i 的值

So now the inner loop is good but you realize that this multiplication isn't necessary either

所以现在内循环效率不错，但你马上意识到第一个乘法也是不必要的

Because what we're doing from i=0 to i=1 to i=2

因为从 i=0 到 i=1 到 i=2

Is we're just increasing the parameter ni by we're adding n to it

因为我们可以通过让 ni 增加 n 来实现

So we can...and that's called a reduction in strength we've taken a multiplication and turned it into addition

这个称为计算量的减少，我们将乘法转化为加法

Because there's some predictable pattern of how this variable ni is going to be updated

因为有一些可预测的模式可以更新这个变量 ni

Another example and again array indexing is a good example for optimizations

这个例子也是关于数组访问优化的

Imagine we had a image that we represent as a two-dimensional array of pixel values

想象一下，我们有一个图片，我们表示为像素值的二维数组

And we want to do something that's what a filtering operation

我们想要做一些过滤操作

Where we want to take the sum of the four neighbors of a given pixel north,south,east and west

我们想要得到一个像素东南西北四个邻居的像素值

And average those together or sum them together

求它们的平均值或它们的和

And so the natural way you'd write this and see is to say I want usually i

实现这个功能最自然的代码

Images you count from the top down and so

是直接求出

You'd say this is the the pixel above,this is the pixel below,this is the pixel to the left,this is the pixel to the right

上下左右四个像素值

And if you do this in and just compile it straight through

类似于左边的代码，然后直接编译它

Unfortunately it appears as if there's three different multiplications by n

会发现汇编代码中有三个乘以 n 的乘法

i-1, i+1 and i

i-1，i+1 和 i

And if the compiler isn't too clever it won't realize that these are related to each other

如果编译器不是太聪明，它不会意识到它们彼此相关

And it will issue three different multiply operations just to do this one pixel thing

对每一个像素，都会做 3 次乘法运算

Whereas if I'm a little more clever

如果我更聪明一点

And this is one where I manually rewrote the code

我会手工重写这部分代码

So the compiler would pick it up

然后重新编译

I'd say well if I ...so inj is i*n+j

改动之后的代码如右图所示，inj 是 i*n+j

And I can get the the pixel above the pixel below by shifting that off setting that by a value of n

我可以通过加减 n 来得到下上像素的值

And then it will issue the code this will compile with the code with just one multiply

然后重新编译代码，这次编译的代码只有一个乘法运算

And in general by the way multiply used to be a very expensive instruction

一般来说，乘法操作非常昂贵

Nowadays is enough hardware resources that it takes about three clock cycles,so it's not a huge deal

但现在有足够的硬件资源，乘法操作需要大约三个时钟周期，所以这不是一个大问题

But anytime you can take three multiplies and use just one instead that's generally a good idea

但是，任何时候你可以使用一个乘法操作替代三个乘法操作，都是有优化的

Question

请讲

[student speaking]

[学生提问]

So the question is what if you're trying to optimize for space

这个问题是，如果你是针对空间进行优化，该怎么做

And there are a lot of optimizations that will

的确，程序有很多优化方式

Make your code be bigger at the expense of in order to go faster right

为了更快地运行，可能需要编写更多代码

This one though I'd argue this is actually shorter code right

这里虽然左边的代码更短

And just look at the number of instructions so

但这里关心的是汇编指令的数量

And usually so code you know that used to be a bigger concern when memory was sort of

在过去，程序占用内存的大小可以是一个比较关注的点

You know back the original IBM pc had 640 kilobytes of memory so

因为原来的 IBM 电脑只有 640k 字节的内存

In its maximum configuration and that was a big deal to actually buy it that much

并且是最高的配置，而且这个电脑的价格并不便宜

So you know back then that was a big deal memory but nowadays memory

所以，过去程序占用的内存大小的限制比较大，但现在

The size of the program is usually a pretty small fraction of what you're dealing with overall

程序的内存大小通常只是你电脑内存的一小部分

But it's a valid question

但这是一个有意义的问题

Okay so that just shows you an example and in general compilers are pretty good at doing

好的，展示这个例子，一般的编译器都非常擅长

Those low-level optimizations like that if you write the code in a way that's reasonable

这种低级优化，如果你编写代码的方式比较合理的话

But there's some other ones that the compiler and even a the fanciest compiler you can buy might not be able to figure it out

但是还有一些其他的代码，你可以购买的最好的编译器也可能无法优化

And so I like to illustrate this with...when the first term we ever taught 213

我喜欢用这个例子来说明这一点......213 课程的第一个学期

I was looking at some lab a code that some of the students wrote

我在实验室里看到一些学生写的这段代码

And I was horrified about this code

我对这段代码感到震惊

And I showed it to the TA and none of them figured out what was wrong

我向助教展示了这段代码，但没有一个人弄清楚出了什么问题

And I've shown it to many other highly-trained C programmers professionals

我已经向许多其他训练有素的 C 程序员专业人员展示过它

They go looks ok to me

他们感觉没什么问题

So let's figure out what's why I was horrified by this code

那么让我们弄清楚为什么我被这段代码吓坏了

So the idea of this code is supposed to be pretty straightforward there's a string s

这段代码的功能非常简单的，有一个字符串 s

And I want to convert that string all the characters in it to lowercase

我想将该字符串中的所有字符转换为小写字母

So I'm just going to read through the string and for each string position

所以我只是遍历这个字符串，对于字符串的每个位置

Test that character and if it's somewhere between upper case a and upper case z

测试那个位置的字符，如果它在大写字母 a 和大写字母z之间

Then I'm going to shift it to being between a and z otherwise I will change it

然后我将它变换到 a 和 z 之间，也就是转化为对应的小写字母

So pretty straightforward

非常简单明了

But if you run this you see that

但如果你运行它，你会看到

If you go up to half a million characters

如果你的字符串到了五十万个字符

Which might sound like a lot but it takes 240 or so so  so four minutes to run this code

需要 240 秒左右，也就是 4 分钟，才能运行完此代码

And you go well that's a pretty big string

这是一个比较大的字符串

It's really not a big string you should be able to do lowercase conversion of a string

但它真的不是一个特别大的字符串，你应该能够在 4 秒钟之内

And a lot less than four seconds

将这个字符串转化为小写

And you also notice this growth is nonlinear it's quadratic

你也注意到这种增长是非线性的，它是二次的

It's growing as the square of the string length,so this is not good

它正在以字符串长度的平方增长，所以这并不好

And unfortunately it's the kind and by the way this is one of the that is very easy surprisingly easy To have programs that have some hidden performance bug

这是一类非常容易有隐藏的性能上的 bug 的程序

That makes them run quadratic

bug 会使程序的增长是二次的

And you run test and you test for strings of 10,000 or less

并且当你的测试数据是 10,000 或更少的字符串时

And it doesn't look like a big deal because the run time is insignificant so

它看起来并不是什么大不了的事，因为运行时间是微不足道的

But then all of a sudden it hits a really bad case

但如果这个程序遇到了字符串比较大的情况

So this is... there's something wrong here

就会出问题

So what's so bad about this program well

所以，为什么这个程序不好

The key is when in a test like this of calling strlen

关键的点是在条件测试中调用 strlen 函数

So the way it's determining whether it's reached the end of the string is by calling strlen to figure out how long the string is

但 strlen 函数是通过测试字符串是否到达末尾的方式来计算字符串的长度

Now and remember if we do the conversion of a for loop into a goto form like you've seen

现在，我们将 for 循环转换为 goto 形式

There's various ways to convert it

有各种方法来进行这个转化

But all of them the test get built into the loop

但是所有这些测试都在循环中

So the main feature of that is this call to strlen will happen every time you go through the loop

因此，每次循环时都会产生对 strlen 的调用

And people overlook that fact

程序员常常忽略了这样一个事实

When you look at the different parts of a for loop

for 循环有三个不同部分

The initialization only gets executed once

初始化只执行一次

But both the tests and the update get incremented get applied every time you run through the loop

但测试和更新每次循环都会执行

So if that's getting called as many times as there are characters in the loop in the string right

因此，strlen 调用的次数，等于字符串中字符的数量

And now how does strlen work

现在看 strlen 如何工作

Remember and see the only way you know how long a string is

查看字符串长度的唯一方法

Is to step through the whole thing and find the null character at the end

是遍历整个字符串直到找到空字符为止

So strlen itself is a linear time operation in the string

因此 strlen 本身就是线性时间的操作

And you're doing that and so you're doing n calls to a function that takes time n

所以，你对一个线性时间函数调用了 n 次 

If the string is getting shorter as you go but not very fast so

执行的过程中字符串越来越短，但是执行的速度不是很快

Basically that's quadratic performance

基本上是二次的

And that explains why you get that runtime

这就解释了为什么我们的运行时间会比较长

So in particular if I just make the following little change

如果我做了以下一些小改动

I introduce a local variable called len

我引入一个名为 len 的局部变量

And I pre compute strlen

我预先计算 strlen

Because the string isn't the length of the string isn't changing I'm just changing the characters in this string

因为字符串的长度没有改变，我们只是改变了这个字符串中的字符

Then so the the program will do the same thing

那么程序将做同样的事情

But now the runtime is so short it doesn't even show up

但是现在运行时很短，甚至都看不出来时间的增长

It's maybe a second to do a million characters it's just not a big deal at all

即使是一百万个字符，也不是什么大不了的事

As it should be it's just running through

因为它仅仅是遍历字符串

And so that's just an example one of many that I've seen in my career where

这只是我职业生涯中见过的许多例子之一

Something that seems almost insignificant turns out to be a serious performance problem

看似无足轻重的事情，最后证明存在严重的性能问题

So why couldn't a compiler figure this out

那么为什么编译器无法解决这个问题

Why couldn't a smart compiler

为什么编译器不能更智能一点

Look at the original code

看看原始代码

And see, you know this is what the programmer wrote

知道这是程序员写的

But I know a better way to do it I'll precompute strlen in advance

但编译器知道更好的方法，会提前预先计算 strlen

Well there's a couple reasons one is actually if you look at the code for strlen

有几个原因使得编译器无法进行此类优化

You see that it's actually modifying the string

第一，这里的代码在循环中修改了字符串

And strlen at this I mean the the code here is modifying the string and we're calling strlen on it

这里我的意思是这里的代码是修改字符串，并且我们调用了 strlen

So you'd have to be pretty careful to do the analysis the compiler would to figure out that

因此，编译器必须非常小心的分析，知道

Even though the string is changing

即使字符串正在改变

The result you're going to get from strlen is not going to change

从 strlen 获得的结果不会改变

So that's a one reason

所以这是一个原因

And the second is...

第二是......

Well and how can the compiler be sure which version of strlen is actually going to get used

那么编译器如何确定哪个版本的 strlen 实际上将被使用

You remember and see each of the files gets compiled separately

因为每个文件都是单独编译的

And only afterwards does it all get brought together in the linking phase

编译之后，它们才会在链接阶段链接在一起

And some of that even happens after the program gets started

其中一些甚至在程序启动后发生

So even though there's a standard strlen function

所以尽管有一个标准的 strlen 函数

It's not necessarily the case that that's the one that will actually get used in the final program

实际上并不一定会在最终的程序中使用它

So the compiler really can't be sure of that

所以编译器真的不能确定调用那个 strlen 函数

In particular imagine I provided a sort of customized strlen function like this

想想一下，我提供了一种这样的自定义 strlen 函数（如 PPT 所示）

That is keeping track of the sum of the lengths of all the strings that it's been called on

它记录调用它的的所有字符串的长度之和

Or some other side effect like that that

或者其他一些副作用

Well that program would produce a very different result than if

那么程序会产生一个非常不同的结果

If I whether or not I make the optimization

如果我进行优化的话

So the compiler has to assume that strlen is just a black box that does whatever it does

所以编译器必须假设 strlen 只是一个黑盒子，它可能做任何事

And can't make any assumptions about what side effects it might have and so forth

并且不能对它能否产生的副作用做出任何假设

So it won't make that optimization on any machine even with the best compiler

所以即使使用最好的编译器，它也不会在任何机器上进行这样的优化

So that's just an example that and you can tell that I've gotten kind of sensitized to this

所以这只是一个例子，你可以告诉我，你已经对此敏感了

So that I spot these but a lot of people don't

所以你发现了这些，但很多人没有

Um so let's look at this

嗯，让我们看看这个

Let's see

嗯

Oh this is another bad example a bad coding example

哦，这是一个糟糕的代码的另一个例子

Of imagine I want to compute for a two-dimensional array a  and 'a' one-dimensional array 'b'

我有一个二维数组 a 和一个一维数组 b

I want to make b be b[i] be the sum of all the elements in row i of  a

我想使 b 的 b[i] 等于 a 中 i 行中所有元素的总和

So again this is a fairly obvious kind of way to write this program that you

这里这个程序写得相当直白

Say well b[i]=0 and I'm going to just accumulate it,I'll step through the row and accumulate all the values

b[i] 初始化为 0，然后遍历 a 的一行，把 a[i][j] 的值累加到 b[i] 上

And of course we know now we could improve this by moving i*n out and so forth

当然，我们现在知道我们可以通过移动 i*n 来改善这一点

I'm not trying to illustrate that

但我想说的不是这一点

But what you'll see in the program this is in the inner loop

主要到在程序的内循环中

And we've looked briefly at some floating-point instructions

我们已经简要介绍了一些浮点指令

And remember that the main feature of them is

它们的主要特征是

The move instructions look like the move ones you're familiar with

移动指令看起来像你熟悉的移动指令

Except when we put floating-point data in one of these %xmm registers

除了我们将浮点数据放在其中一个 ％xmm 寄存器中

So the main thing you see here is it's reading from memory

所以你在这里看到的主要是它从内存中读取数据

It's adding something to it and then it's writing back to memory

然后加上某个值，然后它写回内存

And what that memory location corresponds to b[i]

那个内存位置对应 b[i]

So what it means is every time through this loop it's having to do a memory read and a memory write of b

所以这意味着每次循环都需要从内存中读取 b[i]，然后再把 b[i] 写回内存

In addition to the memory read of a

除了多了内存读取之外

Even though presumably b[i] is the same of value that you just updated it to

b[i] 与上次循环

Well in the previous execution of this loop right

更新的值相同

So why do you have to,why do you read it,why do you write it out

那么你为什么要这样做，为什么要从内存中读取然后再写回到内存呢

And then read it back in increment it and then again copy it back out

然后再从内存中读取，加上某个值，再写到内存中

Why does it have to go keep jumping back and forth between memory and registers over and over again

为什么必须一遍又一遍地在内存和寄存器之间来回传送数据

Well the reason is because in C you can't be sure

原因是因为在 C 中你无法确定是否有

That there isn't what's known as aliasing and I'm demonstrating it here

内存别名使用

Imagine if row b is just declared to be that

想象一下，如果行 b 为 a 中的某一行

Okay so imagine and you can do in C, this is legal C code

好吧，想象一下，在 C 中你可以这样做，这是合法的 C 代码

You can make one memory data structure overlay another data structure

你可以使一个内存数据结构覆盖另一个数据结构

That's referred to as aliasing when too soon as separate parts of the program are referring to the same locations in memory

当程序的不同部分指向内存中的相同位置时，这称为别名

And the C compiler has no way of knowing

并且 C 编译器无法知道是否存在别名

Whether there's a lot of work and optimizing compilers to detect aliasing possibilities

编译器需要做大量的工作来检查是否有内存别名引用

But in general as to assume aliasing might happen

但总的来说，编译器假设存在内存别名引用

So imagine this aliasing happened so that array 'b' can corresponds then to this row of array 'a'

想象一下，数组 b 可以对应于数组 a 中的一行

Well then of course its initial value is 4, 8, 16

所以 b 的初始值是 4，8，16

But if you trace through what this code will do

但是如果你逐步调试这段代码

It has a sort of odd behavior that is probably not useful for anything

你会发现它的行为比较奇怪，可能对任何事情都没用

But it just demonstrates that what will happen is as this as b gets updated

它仅仅表明，当 b 更新的时候

It's effectively changing a and it's changing then what's being read during the summation

它改变了 a，然后影响了求和的结果

And so this is a real possibility in C

在 C 语言中这是可能发生的

And so the compiler when it's given code like this

所以编译器对于这样的代码

It has to assume that the these two memory locations might court overlap each other

它必须假设这两个存储位置可能相互重叠

So that's why it's carefully writing it out and then reading it back in over and over again

所以，编译器会小心地把值写到内存然后一遍又一遍地读回来

And so if I just rewrite this code by introducing again a local variable

因此，如果通过引入局部变量来重写此代码

And accumulating in that local variable

并把求和的结果保存在该局部变量中

And then only at the end do I assign that to b[i]

然后只在最后我赋值 b[i]

Then you'll see this exact same loop all of a sudden gets a lot simpler

然后你会看到这个完全相同的循环突然变得更加简单

It's just a read floating point, read and add to do that

它只是读取一个浮点数，然后加到寄存器

And we'll see in fact the memory is actually one of the limiting perform performance limiters in a program

这里，对内存的读写限制了程序的性能

So this is won't be a significantly faster

所以改写之后不会明显加快

And again that's something that you as a programmer would hardly think is a big deal

再一次重申，作为一名程序员，你很难想到这是一件大事

But the C compiler can't do that in general

但是 C 编译器通常不能进行这样的优化

Because it can't determine in advance what possible aliasing there can be

因为它无法预先确定是否存在的内存别名使用

So as is these two examples C sort of get in the habit of introducing local variables and using them

因此，要习惯这两个例子中引入局部变量的写法

And it's your way of telling the compiler don't call the same function over and over again

这样可以告诉编译器不要一遍又一遍地调用相同函数

Don't read and write the same memory location over and over again just hold it in a temporary one

不要一遍又一遍地读取和写入相同的内存位置，只需将其保存在临时位置即可

And then it will automatically allocate a register and store it in that register and everything will be good

然后编译器会自动分配一个寄存器并将结果存储在该寄存器中，一切都会很好

Okay so that's sort of the the kind of what we call optimization blockers the kind of things that

好的，这就是会阻止编译器优化的一些东西

You as a programmer can make a difference on

作为程序员，你可以帮助编译器进行优化

And the main blockers are memory referencing aliasing and function calls

影响编译器优化的，主要是内存别名使用和

And sort of understanding what might happen in that function call

函数调用中的副作用

And so now what we're going to do is transition

好的，现在我们要转移到另一个话题

Question?[student speaking]

这位同学有问题吗？[学生提问]

Oh no no this is alias C code

不，这是 C 代码（double B[3] = A+3有问题，GCC 编译无法通过）

I'm sure this is known C code because it ran

我确定这是 C 代码，因为我运行过它

This is initializing calling it an array b remember these are in stars these aren't two-dimensional arrays right

这个函数接受两个 double * 的参数，所以它们都不是二维数组

So this is saying a is now a

所以这就是说 a 不是二维数组

Think of it as a linear array of four elements of nine elements

可以把数组 b 想象成 9 个元素数组中的其中 3 个元素

And a plus three is just to go in three

加三表明是从第三个开始

So this is it is declaring b is not a pointer it's an array

所以这就是声明 b 不是指针它是一个数组

But remember with an array you can use the name of that array as a reference to a pointer

但数组的名称也可以作为一个指针

A readable reference not a writable reference right

可以通过指针读写数组

[student speaking]

[学生提问]

Right for this exact code well I'll double check it

对，我会仔细检查仔细检查这段代码

[student speaking]

[学生提问]

So the question is why the C use null terminated strings

所以问题是为什么 C 使用 null 来标识字符串的结尾

And it does and it might be a bad decision for multiple reasons right but

使用这种方式可能是一个糟糕的决定，但多种原因

I think in general think of C was somebody who had or a couple of people

我想，因为 C 语言是由 D.M.Ritchie（补充的）发明

Who had been writing a lot of assembly code and wanted to lift up that level

他曾写过很多汇编代码，想要提升汇编代码的抽象级别

So they weren't writing the same stuff over and over again

因为他们不想一遍又一遍地写同样的东西

But not thinking in terms of how can I be the most abstract possible

所以他们进一步考虑高级的抽象

So they were trying to provide sort of a minimum layer on top of machine level programming

他们只是试图在机器级编程之上提供一个小的抽象

That would let them write code that could run from one machine to another

可以使他们编写的代码，从一个机器跨越到另一台机器

So in everything they do they sort of use the most simple representation and don't assume any kind of

所以，他们设计的 C 语言，都使用最简单的表示方式

There's no array you know most languages would have array bounds checking

例如，大多数语言，数组都有边界检查

And array would be a data structure that would include its size you know range of values and stuff and C just doesn't

数组是一个数据结构，包括它的大小，值的范围和其他的东西，而 C 没有这些东西

So everything about C is suit at the minimum

C 语言值提供基本的功能

And you know it's been around for a 40 or something year so

而且你知道 C 语言已经存在了 40 年左右的时间

[student speaking]

[学生提问]

No pascal does not proceed C no as simply not true

C 语言参考了 Pascal 语言，这不是真的

Pascal was created as a language for teaching by Niklaus Wirth

Pascal 语言是 Niklaus Wirth 发明的，用于教学用的语言

And it was very much an instructional language

它是用于教学的一种语言

So it was really designed to help students who needed help

所以它是帮助学生理解编程

And C was designed by professional programmers to let them write their code and not get in their way

C 由专业程序员设计，帮助他们编写代码，不是为了帮助学生学习

So they're very different theory between the two languages right

所以这两种语言之间的理论区别比较大

[student speaking]

学生提问

I'm sorry,oh yes,that's a mistake there

对不起，哦，是的，那是一个错误

I'll double-check this or people could check it,I'm pretty sure this code is okay though

我会仔细检查这个，你们可以检查一下，我很确定这个代码是没问题的

If not you can certainly say double *B = A + 3 and that would work right

如果有问题，可以改为 double *B = A + 3，这样改了之后没问题了

Question

你有什么问题吗

[student speaking]

[学生提问]

You think what...

你觉得......

-You think this is 28 -Yeah -Well I'm not going to try and execute it here

 -你认为这里应该 28 -是的 -我不会尝试在这里执行这个程序

But let's check it you and I will check this code out

但我们会仔细检查这个代码

And we'll fix it if it needs to be fixed okay, thanks for pointing it out

如果有错误的话我们会修复它，谢谢你指出这个问题

Yeah

是啊

[student speaking]

[学生提问]

No that doesn't make any difference at all in this code

不，这在代码中完全没有任何区别

No know where it's allocated makes no difference at all here

在栈上分配内存还是在堆上分配内存在这里完全没有区别

So I'll check that might have to be double *B=A+3

我会检查一下，这里可能是 double *B=A+3（PPT上应该是写错了，编译通过不了）

But I this was a while ago that I wrote this code oh double-check it

这是我不久前写的代码，但我会仔细检查它

Ok so anyway sets the sort of end of the story for simple simple optima

好吧，无论如何，这种简单的优化往往是在最后才做的

and they are simple optimizations it's just you have to get in the habit of doing it

它们是简单的优化，但你必须养成这样做的习惯

Ok now what we're going to do is go a little bit fancier than this

好，我们现在来看另一种比这个有趣的优化

And as I said this becomes somewhat more system dependent but

正如我所说，这种优化更依赖于系统

Pretty much nowadays all processors are have similar implementation

但是现在几乎所有处理器都实现了这个特性

They all do what's known as out of order execution

名为的无序执行的特性

Except for the most primitive micro controllers

除了最原始的微处理器

And so this is a the kind of optimization oh sure

所以这是一种可以

You'll find well this general approach will work across quite a variety machines

适用于各种各样的机器的通用优化方法

So what I'm going to do is do this by a series of examples

我要通过一系列例子来说明这种优化方法

Starting from some not very efficient code and making it run faster and faster

从一些不是非常高效的代码开始，使其运行得更快更快

And we'll get a speed-up of around 40

优化之后的速度将达到 40 左右

Just in doing what we're doing

仅仅只是做这种优化

So as I'll start by saying well assume I have a data structure

首先我定义一个数据结构

That looks like the way pascal implements arrays

这看起来像 pascal 语言实现数组的方式

Sorry I have nothing against pascal

我没有说 Pascal 语言不好

We used to teach it back in the old days but um

过去我们曾经教过这种语言

So a typical way you'd implement an array in a language is

因此，在一种语言中实现数组的典型方法是

You'd provide both the values that are stored in that array

使用一个数据结构不仅保存数组中的值

And then there'd be other information associated with it for example what size it is

还保存与之相关的其他信息，例如它的大小

And so this is sort of the sort of nice abstract way to do it

所以这是一种很好的抽象方式

And you write code that makes sure that if you ever try to exceed the bounds on the array

你编写的代码可以确保，如果你对数组的访问越界了

You'd return an error signal

会返回一个错误信号

And so this particular function you're seeing is what I want to retrieve an element I passed an a pointer

你看到的这个函数的功能是，从数组中取出索引值对应的元素，传递一个指针

And then that value the pointer gets used to retrieve the value from the array

然后该指针被赋值为数组中索引对应的元素

And the return value of this function is then to 0 or 1 0 meaning failure in one meaning success

此函数的返回值为 0 或 1 0 表示失败，1 表示成功

And I'm writing it this way that I use a datatype I'll call data_t

我将元素的数据类型定义为 data_t

And that way I can run this I can compile this code

这样我可以修改 data_t 的定义，然后重新编译

Using different definitions of data_t to get int,long,floats and doubles

data_t 可以定义为 int，long，float 和 double

And we'll see how the performance characteristics of those shift with the different data types

我们将看到性能特征如何随着不同的数据类型而变化

And the benchmark I'm going to use is a fairly simple one

我使用的基准测试非常简单

It's just to for a an array or one of these vectors

对于这个数组

I just want to combine all the elements of it either compute their sum or their product

我想计算数组中所有元素的总和或累积

And again I'm going to use macros here IDENT and OP

同样，我在这里使用了两个宏定义 IDENT 和 OP

And define those so that OP is addition and the IDENT value is 0

OP 定义为加法，且 IDENT 定义为 0

Or the OP is multiplication and the IDENT element is 1

或者 OP 定义为乘法，且 IDENT 定义为 1

So that I can compare addition in multiplication

这样我就可以对两种运算进行对比

So that gives us sort of eight possibilities here

所以，我们有八种可能

Two different operations in four different data types

四种不同数据类型和两种不同的运算的组合

And so this is written in the sort of most straightforward manner that

基准测试是以最直接的方式编写的

I'm using this function called get_vac_element to retrieve the successive values of this array

我先使用 get_vac_element 的函数来得到数组的第 i 个值

And then performing this operation on them

然后累加或累积到 dest

So now to express a performance of this

现在来看一下这个的性能

We're going to use a metric I introduced called CPE

我们将引入的一个叫 CPE 的指标

Which stands for cycles per element

它代表处理一个元素所花的时间周期

And the idea is that usually when you write code that say steps through a vector

之所以用这个指标，是因为通常当你编写代码遍历处理一个数组时

Anything that has sort of some linear performance as you get bigger

随着数组的增大，处理的时间是线性增长的

You don't really want to know for exactly it takes this many seconds or microseconds or nanoseconds to do an operation

你并不关心对一个元素的处理需要多少秒或多少微秒或多少纳秒

You kind of want to know often more what's its overall performance characteristics

你想知道它的整体性能特征是什么

And also it turns out when you're doing low-level code optimization

进行低级代码优化也是如此

It's much more useful to think in terms of clock cycles of the inner clock of the processor

使用处理器内部时钟的时钟周期作为时间单位更有用

Rather than an absolute term such as nanoseconds

而不是像纳秒这样的时间单位

Because whether a processor is running at two gigahertz or 2.3 gigahertz

因为处理器是以 2G 赫兹运行还是 2.3G 赫兹运行

I don't really I have no control over that as a programmer

一名程序员是无法控制它的

But I can control sort of it the low-level how many clock cycles are being used for different parts of the computation

但程序员可以控制程序中不同的计算部分使用了多少个时钟周期

So that's why it's called cycles per element

所以这就是为什么它被称为每元素的周期数

And you can think of it as and this shows some actual measurements

这里展示了函数实际测量的 CPE 值

But typically a function like this get what I showed the combine will have some overhead

但通常像 combine 这样的函数会有一些额外的开销（类似 size 为 0 时的开销）

A fixed amount that's associated with setting up the loop doing the top of a call and all that stuff

一个固定的开销，因为需要设置循环，调用函数和其他的一些东西

And then some component that's linear in the size

然后是一个线性分量

And so what I want to know is the slope of that linear component

我想知道的是线性分量的斜率

I'll and that will determine that's what I'll call the cycles per element

斜率就是每个元素的周期

You can think that the sort of incremental cost of adding one more element to the array

你可以认为是向数组添加一个元素的增量

So now if I run this function

所以现在如果我运行这个函数

I showed you and I'm only showing I'll mostly only show four results

我这里只展示四种结果

Because it turns out whether it's int or long or float or double

因为事实上，data_t 是 int 还是 long 还是 float 或 double

Is not going to actually have any effect on performance for most of the cases

大多数情况下都不会对性能产生影响

So if I just run this code through a compiler

好，如果我指定优化等级为 0

And don't do any optimizations it takes around 20 cycles per element

每个元素需要大约 20 个时钟周期

And if I turn on optimization level 1 which is sort of the first serious optimization it takes the time in half

如果我优化级别设置为 1，它只需要花费不优化时一半的时间

So I'm down to 10 clock cycles per element just by changing the compilation

因此，只需更改编译器的优化选项，我就可以将每个元素降低到 10 个时钟周期

And that's using the most unoptimized code I could think of here

这个例子所用的代码是我能想到的，最不优化的代码

And then I won't go through it all but using sort of...

然后我们可以进行一些优化...

The kind of things I described earlier of sort of cut away some of the redundancy in this program

我们可以像前面描述的那样，减少这个程序中的一些冗余

You can get it down to something a little bit simpler

把程序变的更简单一点

And so one thing instead of you saw before I was making a call to this

前面看到，每次调用 get_vec_element 函数

get_vec_element and every time it did that it went bounds checking

该函数都会检查数组索引是否越界

And it's kind of silly to keep bounds checking the same array over and over again

一遍又一遍地检查同一个数组是否越界是很愚蠢的

When I'm stepping I'm using its length as the determinate of how many elements to access

所以当我遍历时，我先得到它的长度来确定要访问的元素数量

So if I'm willing to suit a forgo bounds checking

放弃 get_vec_element 函数的边界检查

What I can do is introduce a function that will just give me the actual data storage part of this vector

我可以引入一个函数，它返回数组的长度

And skip over all the other stuff

数组长度之外的东西就直接忽略

And so I can write a loop that and I introduce you know local variables and all the kind of things we described

所以我可以重新编写一个循环，引入局部变量

And accumulating temporaries and things like that

先把数据累加到临时变量，然后再赋值给 dest

Then the program actually gets a lot faster

然后程序实际上变得更快了

Again with this is everything from here out is optimization level 1

重申一下，这里使用的是优化级别 1

And so it drops it down to a little over a clock cycle for integers addition of

它把整数的加法降低到 1 个多时间周期

Or three clock cycles up to five clock cycles for double precision multiplier

整数乘法降低到了 3 个时钟周期，双精度乘法降低到了 5 个时钟周期

So that's pretty good I've sort of definitely improved things

所以这很好，肯定有所改进

But the question is well is that the best there is

但问题是，最好的

And first and well so try to understand what is it about these numbers three five

先解释一下这三个数字怎么来的，3，5

And this seems to be something close to one point two five

和 1.27

So where those numbers coming from and does that indicate some fundamental limitation in my program

这些数字的来源暗示我的程序存在一些基本限制

Well in order to do that you have to have some understanding of the underlying hardware

要理解这些数字的来源，你必须对底层硬件有一些了解

And there's a really good course you can take I think it's called ECE 741

你可以选修一个非常好的课程，ECE 741

That will tell you everything you ever could imagine wanting to know about processor design

它会教你，你能想象的，有关处理器设计的一切知识

And you actually design processors like this

你会自己动手设计了这样的处理器

But I'm assuming you're not going to do that for a while

但我想你暂时不打算那样做

Because you have up seven prerequisites to do before that happens

因为这门课程有 7 门先修课程

So let me just give you the simple version

那么，让我给你一个简单版本的处理器

And this is sort of a an idea of what a processor has looked like since about 1995

这个处理器有点像 1995 年左右的处理器

So this is old stuff but it's enough actually to really understand it

所以这是旧的东西，但真正理解它

It's so hard it's really the details are pretty massive

非常困难，有很多细节

And so it's not even taught for example 447 is the ECE is the computer architecture course

因此，即使是 ECE 447 这样的计算机架构课程也没有讲述这方面的内容

And they don't really go into this kind of design here

他们并没有真正进入这种设计

Because they're pretty hard,they're actually hard to design on your own

因为它们很难，要自己设计非常困难

But the the basic idea is you think about a program as

但基本的想法是，一个程序

As the computer just reads in an instruction does whatever it says to do

计算机会读入一条指令，然后执行这条指令

Reads in another instruction does what that says to do

读取另一条指令，然后执行那条指令

And that has nothing to do with how programs actually execute

这实际上和正在执行的程序无关（程序可以分解为基础指令）

What they've built up is this massive hardware infrastructure

CPU 提供了这个庞大的硬件基础设施

To make a program run way faster than

使程序运行速度比

It would if it were just doing one instruction at a time

一次只执行一条指令快

And it employs a technique that's called superscalar out of order execution

它采用了一种称为超标量乱序执行的技术

And the idea is roughly speaking it

这个想法粗略地讲

It takes your program If you think of your program as a linear sequence of instructions

你可以认为你的程序是一个顺序执行的指令序列

And it just sucks in as many of those as it can

CPU 尽可能的读取多的指令序列

And it pulls it apart to realize that certain operations

然后 CPU 把读入的指令拆开，发现有的指令之间

Don't really depend on each other so I can start one even though it's later in the program

不是相互依赖的，所以我可以开始执行程序后面的代码

Than the one I'm working on right now because they're independent of each other

而不是当前的代码，因为它们彼此独立

And it's extracting what they call instruction level parallelism place is where

这被称为指令级并行性，也就是

Even though your program is a linear sequence of instruction

即使你的程序是一个顺序的指令序列

Buried in there is actually a sort of forest of different computations that need to be done

但实际上，这些代码可以拆分成不同的部分

Some which depend on each other and some which don't

某些部分相互依赖，某些部分不相依

And then it has a bunch of hardware

CPU 有一堆硬件

And so that's up here this upper part shows this idea of fetching instructions

PP T上图的上半部分显示了获取指令的方法

So there's a cache memory a high performance high speed local memory

这里有高性能高速本地缓存

That is just pulling in your instructions as fast as it can

这个缓存只是尽可能快地提取你的指示

And those instructions are then feeding a big pile of hardware that will extract out of it

然后缓存把指令送入指令译码这个硬件中

These low-level operations and figure out which ones depend on which others

这个硬件把指令拆分为低级操作，并确定这些操作之间的依赖关系

And then the there is a set of functional units in this part of it

CPU 还有一组功能单元

That are able to perform these low-level operations to do arithmetic floating-point operations

能够执行这些低级操作，如算术浮点运算

To read data from memory to store data back to memory

从内存中读取数据，写入数据到内存

All using a cache which is something you're going to learn about fairly soon

所有的这些操作都使用缓存，你们很快就会学缓存

How what all this cache is but think of this as a high speed copy of some of the data memory

缓存可以视为某些内存数据的高速副本

And so what this logic tries to do is keep a forking out ,spawning off operations based on your program

总的来做，基本的思想是把你程序的操作进行拆分，重组

And keeping these as busy as they can be

使这些基本单元尽可能保持繁忙

Doing different fragments of your code, doing different instructions in a different order from before

执行代码的不同片段，与以前不同的顺序执行不同的指令

And it turns out you think of a register as a little the set of registers is a part of memory that  get read and written

一组寄存器可以看做是可读可写的一段内存

It turns out that in executing a register now just becomes the name

一个寄存器相当于一个内存符号（寄存器重命名，P360）

Of something that one instruction produces and some other instructions consume

一条指令往写个内存写，其他一些指令读取这个内存

It's a destination for some, it's a source for other

寄存器是一条指令产生数据的目的地，也可以是一些其他指令的数据来源

And this whole a bunch of stuff here just sort of magically passes

有很多数据通过寄存器进行传递

The results of one computation to the input to another computation

可能是一次计算结果，作为另一次计算的输入

Based on register names without ever storing them in an explicit register file

基于寄存器名称而不是将它们显式存储在寄存器文件中

There is a register file when things kind of settle down they get stored away

有一个寄存器文件，当计算的结果出来了，它们将被存储在这里

Anyways there's a lot of stuff going on here

无论如何，这里有很多东西

But the main thing to think about is your machine has resources to do multiple operations all at the same time

但主要考虑的事情是，你的机器有足够的资源，可以同时进行多项操作

If you can somehow structure your program so that those can all get used

但这需要你能以某种方式构建你的程序，才能同时使用这些资源

So this is as I mentioned it's called a superscalar instruct  processor

可以同时进行多项操作的 CPU 被称为超标量指令处理器

Is one that can do more than one instruction every clock cycle

这种 CPU 可以在一个时钟周期执行多条指令

And actually intel started in 1993 the very first Pentium could do two instructions at once

实际上，1993 年，Intel 的 Pentium 处理器就可以同时执行两条指令

But then a little later they came out with one called the Pentium Pro

紧接着他们推出了一款名为 Pentium Pro 的产品

Which is sort of the basis of all modern processors

它是所有现代处理器的基础

And the lead architect by the way was a CMU graduate

顺便说一下，Intel 的首席架构师是 CMU 毕业生

But this out of order execution is the model that's used nowadays

乱序执行是现在处理器的模型

So the other thing is those functional units are more complex than you think they might be

乱序执行比较复杂，但功能单元可能比你想的更加复杂

And that they have what's called pipelining

功能单元使用了流水线技术

And the ideas of pipelining is imagine you can break up a computation into a series of distinct stages

流水线的基本思想是将计算分解为一系列不同的阶段

A simple example is if you want to compute a*b+c

一个简单的例子是你想要计算 a*b+c 的值

You first do the times then you do the plus

你先做乘法，然后做加法

But it actually gets more deep than that you can take something like multiplication

但乘法器做乘法比人算乘法更加复杂

And break it up into smaller steps

乘法器先将乘法分解为可以一个接一个地完成的

That can be done one after the other

更小的步骤

In a way that and then if you have a separate dedicated hardware for each of those stages

你可以认为每个阶段都有一个单独的专用硬件

Then you can do what's called pipelining which is

然后你可以做流水线操作

When one operation moves from one stage to the next

也就是，当一个操作从一个阶段移动到下一个阶段时

A new operation can come in behind and start start its thing

前一个阶段空出来了，你可以填入新的数据

So this example shows imagine I had a three stage pipeline multiplier

请看 PPT 上的例子，我的乘法器分为 3 个阶段

And I want to do this computation a*b, a*c and now multiply those together

我计算 a*b，a*c 然后把两个积相乘

So the thing to observe is that a*b and a*c don't depend on each other in any way

要注意的是 a*b 和 a*c 不以任何方式相互依赖

So I can do them both and I don't have hardware to do them simultaneously

所以我可以同时计算它们两个的积，但我没有两个乘法器

But I have them enough to do one right after the other

但我可以一个接一个地做一个

So I can feed the first computation into the first stage a*b on step time step one

所以，Time 1（PPT 上的表）我可以先计算 a*b 的第一阶段

And then time step two it will move on to stage two

当 Time 2 时，它将继续进入第二阶段

And times step three it will move on to stage three

到了 Time 3，它将进入第三阶段

But now I can start a*c in the time step two

但 Time 2 时，我可以同时计算 a*c 的第一阶段

Because this stage became available

因为这个阶段是空闲的

Once a*b moved from stage 1 to stage 2

当 a*b 从第 1 阶段移至第 2 阶段时

And so I can follow right behind just one clock cycle behind this other operation

所以在其他操作后面的一个时钟周期，我都可以开始新的操作

Now p1*p2 obviously depends on both of these products

现在 p1*p2 显然取决于 a*b 和 a*c 的乘积

So it can't start until a*c is completed

因此，在 a*c 完成之前 p1*p2 无法启动

And then it will run through the pipeline without anything else

然后我们计算 p1*p2，后面没有其他的操作，所以流水线后面是空的

So overall then we've done what would have normally seemed to be nine steps worth of arithmetic

总的来说，我们已经完成了看起来需要 9 个步骤的乘法（3 个乘法 *3 个时钟周期）

In a total of seven steps here because of pipelining

但由于流水线操作，这里总共有七个步骤

Question

这位同学有问题吗

What's...if you had like in this a a picture here

什么...PPT 的这个表

If there were different multipliers in these different places yes you could do

如果在这些不同的地方有不同的乘数，你可以同时执行

Those two completely independent of each other

每个阶段是完全相互独立

[student speaking]

[学生提问]

Yes this is all in a single core of a single processor ,multi-core is yet another

是的，这一切都在单个处理器的单核中，

This is a lower level parallelism than you get through multi-core

单核的这种并行性是一种比多核低的并行性

And it's present except in the sort of lowest n lowest powered embedded processors some version of this exists

除了在低功率的嵌入式处理器中，其他的处理器都提供了这种并行性

And most of the time your hardware is not being fully utilized it's one thing you're going to learn from this

并且大多数时候你的硬件没有得到充分利用

So that's the idea of pipelining it,it's a sort of like parallelism

这就是流水线操作的基本思想，它有点像并行性

But it's not that you have multiple copies of resources it's that you have

但这种并行性不是说你拥有多份资源（如多个乘法器）

This ability to stream operations through a single hardware resource  in close succession to each other

而是把在单个硬件上的操作，划分为紧密联系的顺序的多个步骤

And so as well which is a little bit more recent than the shark machines

嗯，下面将 Haswell CPU，它比 shark 机器（他们上机实验用的机器）要新一点

But not that much more

但也查不了太多

One of the...most recent versions of the intel x86 series

它是英特尔 x86 系列的最新版本之一

And the functional units include there's a lot of functional units that can do different things

Haswell CPU 有许多不同功能的功能单元

But when you add it all up there's a possibility of it doing  two loads and one store

这些功能单元组合起来，可以同时执行 2 次读内存，1 次写内存

Four integer operations two floating-point multiplies one addition and one division

4 次整数运算，两次浮点乘法，一次浮点加法和一次浮点除法

They can't all happen at the same time because there's some are share functional units

这些操作不可能同时发生，因为功能单元之间有一些共享资源

But the point is there's really a lot of equipment there that can do stuff

但功能单元的确比较多

And also you can measure how....

而你也可以测量....

And instruction now has two characteristics and operation is how long does it take from beginning to end

指令有两个参数，延迟（Latency）是一个指令从头到尾需要多长时间

But also how closely spaced can two in stations be because of this pipelining

但由于有流水线操作，还有一个参数（Cycles/Issue）表示两个小步骤之间的距离

So you see that most to them take some number of clock cycles to perform

从 PPT 上我们可以看到，大多数操作需要花费几个时钟周期才能完成

But they're also pipelines so that you can do a series of them

但它们采用了流水线的技术，流水线的一个步骤

Just one cycle apart

只需一个时钟周期

The only different ones that are does you'll notice the division is both very slow and it's not pipelined

注意到，除法操作非常慢，并且没有流水线

And division is a very expensive operation on most machines relatively speaking

所以，相对而言，在大多数机器上，除法是一项非常昂贵的操作

So what I claim then is these characteristics then Provide a limit on how fast our program can run our original program

我讲这两个参数的原因是，它们限制我们程序的运行速度

in that...I have a series of multiplications for example of integers here

举个例子，如果我计算多个整数乘法

And this shows the code for it

PPT 的上方是它的代码

And the result of I need the result of one multiplication before I can begin the next

从代码中可以看出，在我开始下一个乘法之前，我需要上一次乘法的结果

So there's a three clock cycle bound here

每次乘法需要 3 个时钟周期，所以这里得到的结果是 3 个时钟周期

And you'll see that in fact my measurements all correspond to

实际上我的测量结果都符合

What I'm calling the latency bound of these machines which is just based on

我称为机器延迟的限制

How much time it takes from a beginning of an operation to the end

这种限制是基于一个操作从开始到结束需要的时间

And the reason is we considered diagram the computation being done by this program

如果我们把程序的计算顺序画成 PPT 左侧的这张图

That it's doing a series of multiplications

程序进行一系列的乘法运算

And I require the result of one multiplication before I can start the next

并且在我开始下一个之前，我需要上一次乘法的结果

In general if you look at this loop code

如果你看一下这个循环代码

It has to compute %ecx

它必须先计算乘法，更新 %ecx 的值

The updated value of it before it can now start the next one

然后更新 i 的值，再开始下一次循环

And so that's why even though this I have a pipelined multiplier

所以这就是为什么，即使我有一个流水线乘法器

My program itself limits me to of the sequential execution of all the multiplies

但我的程序本身限制了我的所有乘法必须顺序执行

So let's see if we can't get beyond that bound that latency bound

所以让我们看看我们否能超越那个延迟界限

Well there's a fairly common technique that you might have heard of before that's called loop unrolling

这里采用了一种技术，你可能以前听说过，叫做循环展开

And the idea of loop unrolling is just that you

循环展开的基本思想是

Rather than executing one value within a loop you execute a multiple ones

在循环中计算多个值，而不是一个值

And so this code shows unrolling by two

因此，PPT 上的代码展示了 2*1 循环展开

And what it says is I'm going to step through this array two elements at a time

也就是每次循环我处理数组的两个元素

And within each of the inner group I'm going to combine the values  from d[i] and d[i+1]

在循环内部，我计算 x 和 d[i] 及 d[i+1] 的和或乘积

And I have to put in some extra code to finish off

我必须加入一些额外的代码才能完成

What happens if the original rate was very large

如果循环展开值比较大呢

But you get the idea and

我想你明白了

This idea I showed this code of of two

这里我展示了 2*1 的循环展开

But you could imagine this applying for different values of loop unrolling

但你可以想象，这适用于不同的循环展开值

So will this help us any well

这对我们有什么帮助

When I run it I get that the integer addition got a little faster

当我运行它时，整数加法的速度提升了

But the other ones didn't improve at all

但其他的根本没有改善

So this one is going faster

所以这个更快

Because basically the old code is the overhead of the loop indexing and incrementing was enough to be slowing me down

但这个是因为原来的代码在循环的计数上的开销比较大

Because it's already close to a clock cycle

因为原来的代码已经接近一个时钟周期

So I just managed to knock that down to be at the latency bound of this particular instruction

所以我是要超越这个特定指令的延迟界限

But it didn't...have the other ones because I still have this sequential dependency

但它没有...主要原因是我这里的代码也需要顺序执行

In order to get my new value of x I have to first

为了获得 x 的新值，我必须先

Do one computation and then do the other before I can begin another one

乘以 d[i]，然后乘以 d[i+1]，然后开始另一次循环

But this shows me the way I could make a very very small change and change performance fairly dramatically

但我可以做一个非常小的改变，就可以让性能显著提升

What if I take these parentheses and shift them to the right

我把这些括号移到右边（代码中红色的部分）

What would that make any difference

改了之后有什么不同呢

And lo and behold yes you find that

你可以发现运行的时间减少了

And I'll call that transformation unrolling by two computing a one element at a time

我把这种展开称为 2*1 循环展开

I'll talk about that in a minute

我会在一分钟内解释它的含义

But I'll use this lowercase a to say I've done an associate transformation

我这里用小写字母来表示我做的这个基于结合律的转换

And you see all of a sudden my time's dropped in half  for these three cases

你可以发现这样转换之后，三种情况下时间都变为了原来的一半

So something's going on

所以这种转换一定改变了一些东西

Um and so let's see why that isn't and now I'll introduce

现在我来说明为什么会这样

It and so if I take my picture from before

你们想想没有修改的代码

And think about what those computations employ you'll see that

并考虑一下计算的顺序

Right now I've changed the structure of the computation

你会发现我改变了计算的结构

So that I'm pairwise combining each element of pair of elements of the array

改变之后我先计算数组中的两个元素的乘积

And then accumulating those into the overall computation

然后将它们累积到整体的积中

So I've actually that shifting of the parentheses fundamentally changed

所以，实际上括号的转移改变了

How I'm doing my computation

计算的方式

And you can see now that this critical path which is what determines

你现在可以看到，在这个例子中，决定性能

In this case the the performance limitation

的关键路径已经变成了左边这张图

Just got shorter by a factor of two

它的关键路径恰好是前面的一半

And that's why I'm now running twice as fast

这就是我现在的运行速度是前面的两倍的原因

For the operations not for integer addition

但这个转换没有提升整数加法的性能

But for the other three operations I've cut by a factor or two ,just by that shift

但是对于其他三个运算，速度已经提升了一倍，仅仅是改变了括号的位置

Now there's some good news and bad news here

现在这里有一些好消息和坏消息

The good news is if this is integer arithmetic

好消息是，如果这是整数运算

We know already you know that two's complement arithmetic is associative and commutative

你们已经知道了，二进制补码的加法和乘法运算满足交换律和结合律

So it really doesn't matter for both multiplication and addition

因此，整数的乘法和加法进行这种转换都是没问题的

So it really doesn't matter what order I combine these elements in

所以我可以将这些元素以任意的顺序组合

I'm going to get the exact same answer no matter what

无论怎样组合，我都会得到完全相同的答案

But you also solve for floating-point that's not the case

但是你知道对于浮点数的运算，并不满足结合律

So with floating-point that shifting these parentheses

所以对于浮点数运算，如果移动这些括号

Because of rounding possibilities and even potentially overflow

由于可能出现舍入（如大数加小数，小数会被忽略），甚至是溢出的情况

You might get different values results from these computations

可能会导致计算的结果不同

But then again if you think about you know without rounding is going to happen chances are no

但如果在计算过程中不会发生舍入的情况

That it's not really going to affect the outcome of your program

那么这种转换不会影响你的计算结果

But it's enough of a change that most C compilers or most compilers period

但即使发生舍入的情况比较少，但也足够让大多数的编译器

Will not make any change that changes associativity

不会改变浮点数的结合性

Because they're very conservative when it comes to floating-point

因为它们对浮点数计算的优化非常保守

So that's something you as an application programmer has to have to know well enough is

应用程序员，你必须要充分了解这些东西

This a valid can I do this transformation without messing things up

知道做某个转换是不是可能导致错误的结果

And now without I'll say is now there's a new set of bounds

现在有一套新的界限

So a bound is what would appear to be sort of the best you can do based on some constraint in the program

这个界限是你程序能够达到了最好性能

And before it was saying well the latency the total time through a given for a given operation was abound

延迟界限是指在一系列操作必须严格顺序执行时，执行一条指令所要花费的全部时间

And now I say well there's an even more fundamental bound which I'll call the throughput bound

但还有一个更基本的界限，我称之为吞吐量限制

Which is just based on I only have so much hardware out there

这个限制是基于硬件的数量和性能

And I can only a pump it so fast

基于功能单元的原始计算能力

So for example these two that the throughput bound is one

例如，这两个操作的吞吐量界限是 1（上一张 PPT）

Because I only have that actually becomes limited by the requirement

因为它受限于下面的要求

That I'm having to read from memory

我必须把数据从内存中读出来

And I have two different load units

我有两个不同的计算单元

No! I'm sorry I only have one multiplier for integers in one for  addition

没有！对不起，我只有一个整数乘法器，一个整数加法器

The throughput bound for these two actually is just a half

这两者的吞吐量实际上只有 0.5

Because it turns out there's some odd part of the hardware design that has two floating point multipliers

因为这是硬件设计的一个奇怪的地方，它有两个两个浮点乘法器

But only one floating point adder

但只有一个浮点加法器

And we'll see that we can actually make this multiplication code run faster than addition code

所以，这里乘法实际上比加法运行得更快

And over here again my limit will be that I only have two load units ,now I have to be...

这里虽然我有 4 个加法器，但只有两个加载(load)单元，所以性能受限于加载单元

And I have to read for every element I'm computing,I have to be reading one element from memory

因为我必须先从内存中读取一个元素

So I can't get below the

所以我不能低于 0.5

That okay so but we saw this transformation now is let us

我们现在来看看这段代码实现的转化

Break out of this latency limitation and get something closer to throughput

它使我们突破了延迟界限，接近于吞吐量界限

And here's another technique that can be used to again sort of get more parallelism going

这是另一种可以获得更多并行性的技术

And I call this multiple accumulators

我称之为多个累加器

The idea is let's a imagine that

想象一下

We have the odd-numbered elements and the even-numbered elements in the array

我们在数组中有索引为奇数的元素和索引为偶数的元素

And we can we can compute separate sums or products of those two sets of elements

我们可以分别计算这两组元素的和或积

And then the very end combine them together

然后最后将它们组合在一起

So this is another form of and associativity transformation

所以这是另一种形式的结合律变换

You were changing the order in which we combine things together

这改变了元素组合的顺序

It's just that we're doing it in the suit of odd-even manner

我们将索引为奇数的组合在一起，索引为偶数的组合在一起

Or in general every I do it by some by some parameter i

一般来说，我们可以通过参数 i 来将数组划分为多份

It has the same issues that if it's integer arithmetic it's fine

它和前面的转化有同样的问题，如果它是整数运算，那很好

If it's floating-point there's a risk of of changing the behavior of the program

如果它是浮点数，则存在改变程序行为的风险

But you'll see that again we get a cutting in half here and

你会看到整数除加法外，其他的操作运行时间是原来的一半

A little bit below one for integer addition

但比整数的加法要慢一点

And again we can think of it by looking at these pictures

我们看看 PPT 左边的图

Of what are the what gets computed

它表示了我们的计算顺序

And you see what we're doing is we're computing here all the even numbers

我们在这里计算所有偶数

Even numbered elements being combined and here all the odd ones

把偶数编号的元素组合在一起，这里所有奇数编号的元素

And the very end we're combining those together

最后，我们将二者的结果组合在一起

And so we can generalize this if we can unroll by a factor of K of L

进一步的，我们可以将其一般化，我们可以以 K 为因子展开一个长度为 L 的数组

And we can accumulate K results in parallel

这样，我们可以并行计算 K 个值

And we can use various values of l and K for it

我们可以使用不同的 l 和 K 值

In general L has to be a multiple of K

一般来说 L 必须是 K 的倍数

And so you run it out and you can get for floating-point multiply

你可以更改 K 和 L 的值，然后运行程序，这里是浮点数乘法的结果

You can actually get it down almost to this throughput bounds of 0.5

可以看到，实际上运行速度可以接近吞吐量极限 0.5

This is integer,this is integer addition I should say in tradition

这是整数加法的结果

You can again get it down to around 0.5

运行速度也可以接近 0.5

And in general by sort of picking the best parameters

一般来说，通过选择最佳参数

I can get very close to the throughput bound of this processor

我们的运行速度可以非常接近这个处理器的吞吐量界限

So I've been able to take something remember it originally was  20 clock cycles and 10

还记得吗，原来这个程序的 CPE 是 20 个时钟周期和 10 个时钟周期

And now I'm getting it down to one or fewer clock cycles per element

现在我将 CPE 降低到了 1 和 0.5

So now just as the final step is okay is that as good as it go actually know

但我们还可以把它降得更低，现在来看最后一步

You remember when I talked about floating-point I mentioned that there's the special set of registers

讲浮点代码时，我提到过有一组特殊的寄存器

That are on x86 that we're called %xmm registers on the shark machines

在 x86 的机器上，我们称为 ％xmm 寄存器

And now this has well this newer generation have something called %ymm registers

而现在新一代的 CPU 上，增加了一个叫做 ％ymm 的寄存器

Which have the feature being twice as big as %xmm registers

它的大小是 ％xmm 寄存器的两倍

So in particular these registers are 32 bytes long

所以这些寄存器有 32 个字节

And there's a new version coming out within a year or something they call AVX512

并且 Intel 会在一年内推出一个新的名为 AVX512 版本

Where the register is 512 bits so that's 256 bytes long

寄存器为 512 位，因此长度为 256 字节

No it's of to 512,excuse me...it's 64 bytes right

512 比特，对不起......长度应该是 64 字节

64 bytes so it'll be twice as big as these

64 字节，所以它的长度是 %ymm 长度的两倍

And as I mentioned before you can think of these as a way of operating on 32 individual characters

正如我之前提到的，你可以将它们视为 32 个 1 字节的整数

Or I can treat them as floating point

或者把它们视为浮点数

And we saw before that you nowadays the

好，现在

The regular floating point makes use of the low order four, eight bytes of these read register

浮点数使用这些寄存器的低 4 位或低 8 位

But there's also instructions called vector addition

但是，我们有一些称为矢量加法的指令

Where one instruction has the effect of doing eight floating-point additions at once and float data

其中一条矢量加法指令具有执行八次单精度浮点加法的效果

And on double precision this counterpart does four of them at once of these

或者相当于 4 次双精度浮点加法

And the that hardware is there it's just sitting there waiting to use and it seldom gets fired up

但这个硬件很少处于繁忙的状态

To really make use of it

如果这个硬件繁忙起来

But so that floating point multiplier that can do

这样可以较大的提升乘法性能

A floating point multiplication in three clock cycles and is fully pipeline

三个时钟周期，流水线的浮点数乘法

You can actually do eight floating point multiplications in parallel and pipelined in three clock cycles

你可以在三个时钟周期内，并行进行八次浮点流水线乘法

And as I mentioned the shark machines has an earlier version where the numbers are half of these

正如我所提到的，shark 机器是一个早期版本，它的 %ymm 寄存器的长度是这里的一半

So it can do 4 single precision or two double precision at once

因此它可以同时执行 4 个单精度或两个双精度的浮点数运算

And if I write code that uses that what I call vector code

如果我把代码改写为矢量代码

Then you can see I can drop by a factor of about four across the board here

然后你可以看到 CPE 降低了 4 倍

And make it run much faster

所以运行速度更快了

So this 0.06 is really 0.0625 right

这个 0.06 是 0.0625

It's doing 16 operations per clock cycle on that

它每个时钟周期执行 16 次操作（原来每个时钟周期执行 2 次操作，提升了 8 倍）

And can't quite hit the vector throughput bound

但是我们最多只能接近矢量吞吐量界限

But in general making this thing run much faster

但总的来说，运行速度已经提升了很多

And so the people really worry about

所以人们真的很关心

And you can imagine these instructions were introduced for things like video processing image processing of sound

你可以想象，这些指令是为视频、声音、图象处理而引入的

Sort of signal processing where a performance really matters

这些信号处理的程序对性能的要求很高

How fast you can display an image how fast you can rotate something

如，显示图像的速度有多快，将某个图象旋转速度有多快

You know how fast you can perform graphics makes a big difference

渲染图象速度的快慢影响很大

In video games are one of the big drivers but even for sort of other operations you might do an image

在电脑游戏中这是一个关键因素，在其他领域也比较重要，如你拍摄一张照片

And so these instructions were really designed to do it

这些指令就是为了这些情景设计的

And people write code for those kind of applications

人们为这些应用程序编写代码

Get pretty good at writing code in a way that they can do this vector I what's called vectorizing

他们需要编写这种向量化的代码

And unfortunately so the intel compiler will actually automatically do some of this for you

不幸的是，虽然 intel 编译器会自动做一些这方面的优化

A GCC they attempted to implement it and

但 gcc 虽然尝试去实现这种优化

It didn't work very well so I think they discontinued it

但实际效果不好，可能 gcc 已经没有继续这个优化了

It turns out there's a web aside

这里有一个网络旁注

So this is on the web from the books web page that describes

对应的网页上讲了

How to do this programming if you're interested

如何进行这种向量化的编程，有兴趣你可以试试

There's extensions to GCC that are very funky really weird stuff

网页上还有一些 gcc 的扩展

But you can write code

但是你可以编写代码

That then will get compiled down to make use of these kind of instructions

然后利用 gcc 的扩展（补充）编译，这样就可以利用这些矢量指令

And that's how I did it and how I got these performance results

这是我的做法，也是我得到这个性能的测试结果的方法

Okay so that shows you if you really want to it

这是我要展示的结果

But that's very machine specific that will only work on

还有一点，这种优化是针对某个机器的

Well you have to you can actually tune it so it's easy to compile it  to go between different machines

如果你要在不同的机器上运行程序，你需要调整 gcc 的选项

But it's still a fairly specific and very specific to GCC in fact

这种优化依赖于 gcc

So that sort of shows you though if you really want to push it what you can do

如果你想自己编写代码，你可以试一试

Now let's uh get back to one of the thing

现在我们来讨论另外一件事情

I told you about how you can if you think of your program as a very long linear sequence of instructions

前面为了简化，我们程序是一个非常长的顺序结构的指令

Then the thing is trying to grab as many of those and pull them apart as fast as it can

然后我们的 CPU 一次读取尽可能多的指令，然后把这些指令分开

But of course you know your program is actually typically a loop

但是，我们这里的程序实际上是一个循环

And there aren't many instructions in that loop

并且循环中的指令不多

So how is it turning that into a linear sequence

那怎么把它变成一个顺序指令呢

Well that relies on an idea of how do you handle branches

这依赖于处理条件指令的方法

So typically the program you know fetching ahead grabbing instructions

所以，现在你知道，CPU 会读取指令

And it will come to a branch instruction a conditional jump of some sort

如果指令中有跳转指令，CPU 会跳转到对应的分支中去执行

And there is a dilemma because in general this branch could either

这里就出现了一个两难的境地，因为这一个分支也可能被执行

I'm sorry either be taken meaning it will go to the branch target

抱歉，这里的意思是，如果条件满足，它会跳转到对应的对应的分支

Or it could do what's called fall through meaning it it the test fails and so it just continues execution

如果条件不满足，它会继续执行后面的代码

And there's no way a priority to know what will happen these can often be data dependent

并且我们没有办法事先知道那个哪个会被执行，因为这与数据有关

Well and so the way this is handled on a modern processor is by doing

所以，在现代处理器是这样处理这种情况的

What's known as branch prediction which is essentially just guess

它采用所谓的分支预测，但本质上只是猜测

Which ways this branch going to go is going to be taken or

猜测哪一个分支会被执行

Not and you predict and then you start executing along the predicted direction

然后 CPU 会执行对应分支的代码

But do it in a way that if you make a mistake that

但执行对应代码的时候，必须能够保证

You haven't caused your reparable harm to the program

没有对该程序造成不可修复的损害

And we'll see what that means

我们会看到这意味着什么

So what really happens then is up here there's a lot of logic

指令控制单元（上半部分）中有许多逻辑单元

That's trying to suck out instructions

指令高速缓存会读取指令

And then there's a branch unit that's being basically coming along later and saying

如果遇到了分支，会先执行某个分支，当执行到后面（乱序）

Yeah you're okay you predicted that correctly so you can keep going

发现预测是正确的，就会接着往下面指令

Or it will throw up a flag and say oh wait a minute stop

如果预测不正确

You miss predicted this branch way back 100 clock cycles ago

你可能要回到 100 个时钟周期前

It's not that long ago but

这不是很久以前的事

Some number of clock cycles ago you've got to fix it

你需要回到分支点，然后开始取出和指令另一个方向上的指令

And so the hand-wave jumps then becomes more a case of

因此，跳转指令的指令变成了这样

Of guessing up here and then either confirming or  denying that guess down below

先执行猜测的分支，然后在后面判断猜测是否正确

So in general then if you it will predict it one way and begin executing

所以总的来说，如果你它会以一种方式预测并开始执行一个分支

So a mention for example in a loop like I've shown you

举个例子，这里有一个循环

That you predict that the branch will be taken that you'll go back to the start of the loop again

预测不会跳转，执行后面的内容，然后会再次回到循环的开始

That's actually a pretty good guess

实际上，这是一个很好的猜测

It's a good guess extol you hit the end of the loop

因为这执行到了循环的结尾

But let's just guess that way

但是我们会继续这么猜

And so the program will just keep guessing that the branch will be taken

因此程序继续执行循环体的内容

And by that means by all those guesses basically create this long linear sequence of instructions

通过这种方式，创建了一个长的顺序指令序列

That can be pulled in and executed

功能单元可以读取并执行

And in general some of them will be fetched and some of them you'll actually have done

一般来说，一些指令是有效的，而一些指令是多余的

The operations that are called for in the instruction

因为已经完成了所有的操作

And then what happens is if the flag goes up they say no this was invalid

然后继续执行的时候，一个标志位会提示当前的分支不是无效的

Then what will happen is it will go back and cancel

然后它会返回

All the instructions that have been fetched and executed

并且取消所有已读取并执行的指令

And the way it does that is you'll notice all these instructions only modify registers

注意，这里所有的指令都只修改寄存器

And it has multiple copies of all the registers

并且，它有所有寄存器的多个副本

Going back these are the registers

回退的时候，这些寄存器

These are the values that I'm sure of these are sort of speculative values  appending updates to them

每一次计算的结果都依次保存在寄存器副本中，所以，猜测正确的在前，猜测错误的在后

And so when it comes time to cancel it just cancels out all those pending updates

因此，当需要取消它时，只需取消所有待处理的更新

And goes back to values that it's certain of

并把正确的值返回（前面是存储在副本中，并没有真正更新寄存器）

Question

这位同学有什么问题吗

The there's a big block they call the register renaming unit which is sort of

在 CPU 中，有一个寄存器重命名块

Multiple copies of of all the registers as they get accumulated

它对每一个寄存器都有多个副本，计算的结果就保存在这些副本中

[student speaking]

[学生提问]

It has many more will typically have several hundred reg of these

对于每个寄存器，它通常有几百个虚拟寄存器（副本）

Sort of virtual registers to keep pending copies to the actual registers

用于存储需要更新到实际寄存器的值

[student speaking]

[学生提问]

It does, it stores

嗯，对，它记录

You know here's the old value Here's the first update here's the second update here's the third

更新的次数，知道这是第一次更新，这是第二次更新，这是第三次更新

And it keeps track of all that you can imagine why this is not something you learn in a one semester course right that

它记录了你可以想象的一切，这不是你在一学期课程中能够学完的内容

To keep track of all those different things flying by and make sure that it works is a pretty tricky business

它需要记录所有的内容，所以，确保它能够正常工作相当棘手

But the conceptually it's a pretty simple idea

但从概念上讲，这是一个非常简单的想法

That it just races off does a lot of things based purely on speculation

它只是基于猜测提前做了许多工作

And then only if it makes a mistake it goes oh

然后只有在出错的情况下才会

And it sort of rolls back

回退到某一个点

To as if it had only executed up to a certain point

好像它只执行到了那个点

And then it moves forward

然后它继续执行

And starts in going the correct way

后面正确的分支

So end up,and so it can get away with this,it's very interesting tricky stuff

它是如何回退的，这是非常有趣且棘手的内容

But you remember we talked early in the course

我们在课程的早期谈过

About the difference between using conditional moves and conditional jumps to implement conditional operations

关于条件传送和条件分支代码的区别（书 P145）

And conditional moves can take place totally within the structure of this pipeline

条件传送可以在管道的结构内进行

But a conditional jump if it's an unpredictable branch

如果是条件分支代码，并且是一个不可预测的数据

The problem is it might go off executing and make do a lot of wasted work

可能会执行大量无效的工作

But even worse than when it gets back and has to restart

但更糟糕的是，当它不得不回来重新启动时

It takes a while to sort of fill up all the the buffers in the system

需要一段时间来填充系统中的所有缓冲区

And get the whole thing running at full steam ahead

才能继续执行后面的代码

So that kind of finishes up then the the way I describe it is

这节课差不多要结束了

First of all don't do anything stupid even and stupid is probably it was too strong a word

总结一下，首先，不要做任何愚蠢的事情，愚蠢可能说的有点过了

Don't do...sort of keep in mind there's certain things that you should as a programmer be doing all the time

然后，记住，作为一名程序员，你一直在做的某些事情可能是有问题的

And they're not obvious

它们并不明显

And then begin thinking about tuning and getting some instruction level parallelism

然后，我们讨论了如何通过调整代码来获得一些指令级并行性

And I describe it as for the machine but

它们是和具体的机器相关的

As I said pretty much all processors nowadays,it's a class of machines

但现在几乎所有的机器，都属于一类机器

So these general techniques will work

所以，改变计算的结合性，这种技术

That those ideas of changing the associativity

几乎对所有机器都是有效的

They'll work whether it's a you know the ARM processor built into my cell phone

无论是手机中的 ARM 处理器

Or the x86 processor built into your laptop or one of the shark machines

或者是笔记本电脑或 shark 机器中的 x86 处理器

They all have the same general of implementation structures

它们都具有相同的实现结构

So these techniques will work across across all of them

因此，这些技术将适用于这些所有的机器

Okay that'll do us for today

好的，今天我们的课程就到这